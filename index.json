[{"content":"Some tips and tricks for the CP-SAT solver.\nResources: https://github.com/or-tools/awesome_or-tools https://stackoverflow.com/questions/tagged/or-tools https://or.stackexchange.com/questions/tagged/or-tools https://groups.google.com/g/or-tools-discuss https://github.com/google/or-tools/discussions https://discord.gg/ENkQrdf Solver Parameters By default, OR-tools will try to use all available cores but you can set num_search_workers manually.\nsolver.parameters.num_search_workers = 8 If the program silently crashes you can enable logging to get more info.\nsolver.parameters.log_search_progress = True You can also see which worker is better for your problem and improve the single core performance by setting the same parameters.\nSearch for all optimal solutions You can\u0026rsquo;t enumerate all solutions if you have an objective, so you have to do it in two steps:\n# Get the optimal objective value model.Maximize(objective) solver.Solve(model) # Set the objective to a fixed value # use round() instead of int() model.Add(objective == round(solver.ObjectiveValue())) model.Proto().ClearField(\u0026#39;objective\u0026#39;) # Search for all solutions solver.parameters.enumerate_all_solutions = True solver.Solve(model, cp_model.VarArraySolutionPrinter([x, y, z])) Non-contiguous Intvar Alternatives to model.NewIntVar(lb, ub, name), solving might be faster:\n# List of values model.NewIntVarFromDomain( cp_model.Domain.FromValues([1, 3, 4, 6]), \u0026#39;x\u0026#39; ) # List of intervals model.NewIntVarFromDomain( cp_model.Domain.FromIntervals([[1, 2], [4, 6]]), \u0026#39;x\u0026#39; ) # Exclude [-1, 1] model.NewIntVarFromDomain( cp_model.Domain.FromIntervals([[cp_model.INT_MIN, -2], [2, cp_model.INT_MAX]]), \u0026#39;x\u0026#39; ) # Constant model.NewConstant(154) Domains Working with Domains gives a lot of flexibility and should be faster than creating multiple constraints.\ndomain = cp_model.Domain(0, 10) domain = cp_model.Domain.FromValues([1, 3, 4, 6]) domain = cp_model.Domain.FromIntervals([[1, 2], [4, 6]]) domain = cp_model.Domain.FromIntervals([ [cp_model.INT_MIN, -2], [2, cp_model.INT_MAX] ]) model.AddLinearExpressionInDomain(sum(my_vars), domain).OnlyEnforceIf(b) Iff, equivalence, boolean product p \u0026lt;=\u0026gt; (x and y)\n# (x and y) =\u0026gt; p, rewrite as not(x and y) or p model.AddBoolOr([x.Not(), y.Not(), p]) # p =\u0026gt; (x and y) model.AddImplication(p, x) model.AddImplication(p, y) Boolean sum, boolean or p \u0026lt;=\u0026gt; (x or y)\n# p =\u0026gt; (x or y), rewrite as not(p) or x or y model.AddBoolOr([x, y, p.Not()]) # (x or y) =\u0026gt; p model.AddImplication(x, p) model.AddImplication(y, p) Note: see De Morgan\u0026rsquo;s laws\nBoolean Implications # a =\u0026gt; b (both booleans) model.AddImplication(a, b) # a \u0026lt;=\u0026gt; b (use only one of them if you can) model.Add(a == b) # a and b and c =\u0026gt; d model.Add(d == 1).OnlyEnforceIf([a, b, c]) or model.AddBoolOr([a.Not(), b.Not(), c.Not(), d]) If-Then-Else Using intermediate boolean variables.\nb = model.NewBoolVar(\u0026#39;b\u0026#39;) # Implement b == (x \u0026gt;= 5). model.Add(x \u0026gt;= 5).OnlyEnforceIf(b) model.Add(x \u0026lt; 5).OnlyEnforceIf(b.Not()) Solution hint / Warm start It may speed up the search.\nnum_vals = 3 x = model.NewIntVar(0, num_vals - 1, \u0026#39;x\u0026#39;) y = model.NewIntVar(0, num_vals - 1, \u0026#39;y\u0026#39;) z = model.NewIntVar(0, num_vals - 1, \u0026#39;z\u0026#39;) model.Add(x != y) model.Maximize(x + 2 * y + 3 * z) # Solution hinting: x \u0026lt;- 1, y \u0026lt;- 2 model.AddHint(x, 1) model.AddHint(y, 2) Storing Multi-index variables I recommend using dictionary comprehensions:\nemployee_works_day = { (e, day): model.NewBoolVar(f\u0026#34;{e} works {day}\u0026#34;) for e in employees for day in days } Variable product (Non linear) You have to create an intermediate variable:\nx = model.NewIntvar(0, 8, \u0026#39;x\u0026#39;) y = model.NewIntvar(0, 5, \u0026#39;y\u0026#39;) xy = model.NewIntVar(0, 8*5, \u0026#39;xy\u0026#39;) model.AddMultiplicationEquality(xy, [x, y]) Black box function (Non linear) As your last resort you can precalculate all the posible values and use an element constraint.\nfrom ortools.sat.python import cp_model model = cp_model.CpModel() x = model.NewIntVar(0, 10, \u0026#34;\u0026#34;) two_to_the_x = model.NewIntVar(1, 2 ** 10, \u0026#34;\u0026#34;) precalculated = [2 ** i for i in range(11)] model.AddElement(x, precalculated, two_to_the_x) # test model.Add(x == 3) solver = cp_model.CpSolver() solver.Solve(model) print(\u0026#34;x\u0026#34;, solver.Value(x)) print(\u0026#34;2**x\u0026#34;, solver.Value(two_to_the_x)) Load model Proto This allows you to use different machines.\nfrom google.protobuf import text_format from ortools.sat.python import cp_model model = cp_model.CpModel() a = model.NewIntVar(0, 10, \u0026#34;a\u0026#34;) b = model.NewIntVar(0, 10, \u0026#34;b\u0026#34;) model.Maximize(a + b) new_model = cp_model.CpModel() text_format.Parse(str(model), new_model.Proto()) solver = cp_model.CpSolver() status = solver.Solve(new_model) print(solver.StatusName(status)) print(solver.ObjectiveValue()) Circuit constraint (ordering) Ordering the numbers from 1 to 10 so that we maximize the distance between between numbers:\nfrom itertools import permutations from ortools.sat.python import cp_model model = cp_model.CpModel() solver = cp_model.CpSolver() literals = {} # An arc is just a (int, int, BoolVar) tuple all_arcs = [] nodes = range(1, 11) for i in nodes: # We use 0 as a dummy nodes as we don\u0026#39;t have an actual circuit literals[0, i] = model.NewBoolVar(f\u0026#34;0 -\u0026gt; {i}\u0026#34;) # start arc literals[i, 0] = model.NewBoolVar(f\u0026#34;{i} -\u0026gt; 0\u0026#34;) # end arc all_arcs.append([0, i, literals[0, i]]) all_arcs.append([i, 0, literals[i, 0]]) for i, j in permutations(nodes, 2): # this booleans will be true if the arc is present literals[i, j] = model.NewBoolVar(f\u0026#34;{i} -\u0026gt; {j}\u0026#34;) all_arcs.append([i, j, literals[i, j]]) # to make an arc optional, add the [i, i, True] loop model.AddCircuit(all_arcs) model.Maximize(sum(literals[i, j] * abs(i - j) for i, j in permutations(nodes, 2))) solver.Solve(model) node = 0 print(node, end=\u0026#34;\u0026#34;) while True: for i in nodes: if i != node and solver.Value(literals[node, i]): print(f\u0026#34; -\u0026gt; {i}\u0026#34;, end=\u0026#34;\u0026#34;) node = i break else: break print(\u0026#34; -\u0026gt; 0\u0026#34;) Fairness, distribute items evenly Maximize the minimum value model = cp_model.CpModel() n_tasks = 100 n_employees = 3 min_tasks = model.NewIntVar(0, n_tasks, \u0026#34;\u0026#34;) employee_tasks = [model.NewIntVar(0, n_tasks, \u0026#34;\u0026#34;) for _ in range(n_employees)] model.Add(sum(employee_tasks) == n_tasks) model.AddMinEquality(min_tasks, employee_tasks) model.Maximize(min_tasks) solver = cp_model.CpSolver() status = solver.Solve(model) print([solver.Value(n) for n in employee_tasks]) Minimize delta to the average value model = cp_model.CpModel() n_tasks = 100 n_employees = 3 avg = n_tasks // n_employees delta = model.NewIntVar(0, n_tasks, \u0026#34;\u0026#34;) employee_tasks = [model.NewIntVar(0, n_tasks, \u0026#34;\u0026#34;) for _ in range(n_employees)] model.Add(sum(employee_tasks) == n_tasks) for i in range(n_employees): model.Add(employee_tasks[i] \u0026lt;= avg + delta) model.Add(employee_tasks[i] \u0026gt;= avg - delta) model.Minimize(delta) solver = cp_model.CpSolver() status = solver.Solve(model) print([solver.Value(n) for n in employee_tasks]) Multiobjective optimization Two ways to achieve that:\nAdd a weight to each objective Solve with the first objective, constraint the objective with the solution, hint and solve with the new objective. from ortools.sat.python import cp_model model = cp_model.CpModel() solver = cp_model.CpSolver() x = model.NewIntVar(0, 10, \u0026#34;x\u0026#34;) y = model.NewIntVar(0, 10, \u0026#34;y\u0026#34;) # Maximize x model.Maximize(x) solver.Solve(model) print(\u0026#34;x\u0026#34;, solver.Value(x)) print(\u0026#34;y\u0026#34;, solver.Value(y)) print() # Hint (speed up solving) model.AddHint(x, solver.Value(x)) model.AddHint(y, solver.Value(y)) # Maximize y (and constraint prev objective) model.Add(x == round(solver.ObjectiveValue())) # use \u0026lt;= or \u0026gt;= if not optimal model.Maximize(y) solver.Solve(model) print(\u0026#34;x\u0026#34;, solver.Value(x)) print(\u0026#34;y\u0026#34;, solver.Value(y)) Soft constraints https://stackoverflow.com/a/66377562\nEarly stopping Stop if objective does not improve.\nfrom threading import Timer from ortools.sat.python import cp_model class ObjectiveEarlyStopping(cp_model.CpSolverSolutionCallback): def __init__(self, timer_limit: int): super(ObjectiveEarlyStopping, self).__init__() self._timer_limit = timer_limit self._timer = None self._reset_timer() # Remove to guarantee a solution def on_solution_callback(self): self._reset_timer() def _reset_timer(self): if self._timer: self._timer.cancel() self._timer = Timer(self._timer_limit, self.StopSearch) self._timer.start() def StopSearch(self): print(f\u0026#34;{self._timer_limit} seconds without improvement\u0026#34;) super().StopSearch() ","permalink":"https://xiang.es/posts/cp-sat/","summary":"\u003cp\u003eSome tips and tricks for the CP-SAT solver.\u003c/p\u003e","title":"‚ú® Recipes for Google OR-Tools"},{"content":"List of tools I use daily\nCoding IDE: Coding IDE: PyCharm / VS Code Autocompletion: Copilot / Tabnine Formatters: black / prettier Questions: Stack Overflow / Reddit Code search: Sourcegraph / Github Libraries list: Awesome / Awesome-python / Bundlephobia VCS Hosting: Github / Gitlab / Bitbucket / Devops Conventions: Gitmoji / Conventional Comments / Conventional Commits pre-commit Oh Shit, Git Communication Chat: Slack / Teams / Google Chat / Discord Tickets: Trello / Jira Documentation: Confluence Code sharing: Pastebin / carbon API Tunneling: ngrok HTTP Client: Postman / Insomnia / httpie Spec: Stoplight studio / Swagger / Async API JSON: JSON Viewer / Json formatter Other: Let\u0026rsquo;s Encrypt / Cloudflare DB SQL: DBeaver NoSQL: MongoDB Compass / NoSQLBooster / Robomongo Devops CI/CD: Jenkins / GitHub Actions Static Analysis: SonarQube Docker: Docker Desktop / Docker Compose / Lens Other Diagrams: Excalidraw / draw.io / jsonvisio / sequencediagram Office: Google docs PDF, image editing: tinywow Data generator: DNI generator / RandomKeyGen PassWords: KeePass / KeePassXC Browsers: Chrome / Firefox Developer Edition Browser Plugins: Awesome Screen / Json viewer Music: Spotify / Lofi Girl Stock images: Unsplash / Pexels / FreePik Workstation Nox Hummer ZX Asus VG278Q 144Hz MSI GTX 1060 GAMING X 6GB MSI Z270 Gaming M3 Intel Core i7-7700K 2x HyperX Fury RAM 8 GB (2133 MHz) Logitech TKL keyboard Logitech G903 mouse + Powerplay Logitech C922 Pro Webcam Astro A50 headset ","permalink":"https://xiang.es/posts/tooling/","summary":"\u003cp\u003eList of tools I use daily\u003c/p\u003e","title":"üî® My Development Tools"},{"content":"üöß WORK IN PROGRESS\nReferences and things to learn.\nhttps://roadmap.sh/backend/ https://roadmap.sh/software-architect/ General books The Pragmatic Programmer Software Engineering at Google Clean Code Summary: don\u0026rsquo;t read the book Python Cheatsheet\nBasics Download Python and Visual Studio Code with the Python extension, start with simple single file scripts.\nIntroducing Python (2019): Basics, ignore everything after chapter 11 Practice Codewards, very important to checkout other solutions after submitting Skim through pep8 Learn a bit of DSA (Data Structures and Algorithms), do easies in neetcode Projects: Make a discord bot with discord.py Program a simple game with PyGame such as Snake Deploy a simple Flask website in Deta Advanced Switch to PyCharm once you are familiar with the syntax and concepts such as virtualenvs, git, etc.\nRead: Fluent Python (2022) Architecture Patterns with Python Watch: ArjanCodes: Advanced, refactoring videos are great. mCoding: Trivia, watch popular videos. Learn about testing: https://testdriven.io/guides/complete-python/ Learn about Design Patterns and their implementation in python, but don\u0026rsquo;t overdo it. News: Latest Python features: read summaries Reddit: Check top posts by year or month Top libraries: by year Checkout some Open Source projects, bonus you have used them before: arrow: highly recommended minecraft: 900 lines requests and httpx arq: small project, take a good look at every file typer Note\nUse venv and pip-tools for dependency management, poetry is also a good option, specially for packaging. Avoid pipenv.\nVersion Control (Git) https://docs.github.com/en/get-started/quickstart/hello-world https://training.github.com/downloads/github-git-cheat-sheet/ https://ohshitgit.com/ https://gitmoji.dev/ git checkout develop git pull git checkout -b feature/new-feature git add . git commit -m \u0026#34;:sparkles: Some new thing\u0026#34; git push Web Development Basics How does the Internet work? What is a web server? What is a domain name? What is HTTP? How browsers work What is DNS? ","permalink":"https://xiang.es/posts/roadmap/","summary":"\u003cp\u003eüöß WORK IN PROGRESS\u003c/p\u003e\n\u003cp\u003eReferences and things to learn.\u003c/p\u003e","title":"üó∫Ô∏è Personal Roadmap"},{"content":"Some notes about microservices\nReference Building Microservices Microservices Indendently releasable/deployable services (loosely coupled, stable contracts). Modeled around a business domain (end-to-end slices of business functionality). Implementation details are hidden (owning their own state, no sharing of databases, different technologies/try new things, etc). Tip\nThey allow developers to work independently, reducing delivery contention. (Technology Heterogeneity, Robustness, Scaling, Ease of Deployment, Organizational Alignment, Composability, etc)\nInfo\nThey are not a great idea if the product is brand new or the domain is undergoing significant change. Also, if the team is small, the time spent on deployment and management might not be worth it. (Developer Experience, Deployment Overhead, Cost, Reporting, Monitoring, Security, Testing, Latency, Data Consistency, etc)\nMonoliths A valid default choice, doesn\u0026rsquo;t mean legacy.\nSingle-process monoliths: most common, single process that talks to a database (monolithic Django, Rails, etc). Modular monoliths: single process with separate modules that can be worked on independently (shopify). Distributed monolith: multiple services that must be deployed together (disadvages of distributed systems and single-process monoliths, not enough focus on information hiding and cohesion of business functionality). Microservice Boundary Information Hiding: improve development time by allowing more things to be worked on in parallel, allow each module to be understood in isolation and allow modules to be changed independently. The important thing is to form good boundaries between modules. Cohesion The code that changes together, stays together.\nWe want the functionality grouped in a way that we have to make changes in as few places as possible. Avoiding the need to deploy multiple services at the same time.\nCoupling A structure is stable if cohesion is strong and coupling is low.\nSome coupling is inevitable, but we want to minimize it. A loosely coupled service knows as little as it needs to about the other services. Limiting the number of different types of calls is also important, chatty communication is a sign of tight coupling.\nDomain Coupling: Largely unavoidable, occurs when one microservice needs a functionality that the other provides. If a microservice needs to talk to a lot of other microservices it might be doing too much. Also, remember to send only the absolute minimum amount of data needed. Temporal Coupling: One microservice needs another to do something at the same time (synchronous HTTP call), it isn\u0026rsquo;t inherently bad, but with more microservices it can cause issues if you want to scale. Pass-Through Coupling: one microservice passes data to another microservice because it is needed by some other downstream microservice. There are some ways to improve this: bypass the intermediary, make the intermediary take in data in its contract and delegate the formatting to it or make the intermediary treat the needed data as an opaque blob. Common Coupling: two o more microservices use a common set of data (shared database, shared memory or filesystem), changing the structure of the data can impact multiple services. This can be a big problem if the structure of the common data changes frequently / multiple microservices are reading and writing. Who should be responsible of managing the correct lifecycle of the data, do we make a thin CRUD wrapper and reduce cohesion? Content Coupling: similar to common coupling but there is no clear knowledge about ownership of the data (eg: one microserve makes changes to a database bypassing the actual service that exposes the data). DDD Important concepts for building microservices:\nUbiquitous Language: the same language is used by all the stakeholders (developers, business, etc). Aggregates: a group of objects that are treated as a unit for the purpose of data changes, typically have a life cycle around them / state machine. Bounded Context: organizational boundary, internal concerns should be hidden, make use of hidden models and shared models of associated aggregates. Mapping Aggregates and Bounded Contexts to Microservices: you can always star with a coarser-grained API and split into more microservices if needed (implementation detail). Event Storming: a technique for building a domain model with both technical and nontechnical stakeholders. Alternatives:\nVolatility: extract parts that go through a lot of changes (eg: bimodal IT, Mode 1 and Mode 2), not very recommended. Data: driven by privacy and security concerns, to reduce risk of data breaches and simplify oversight. Technology: this isn\u0026rsquo;t really a general means of decomposition. Organizational: driven by the organizational structure of the company, prefer end-to-end vertical slice instead of a horizontal slice. Splitting the Monolith Microservices are not the goal just a means to an end. Incremental migration, identify quick wins, avoid premature decomposition. Balance difficulty with benefits. Patterns: Strangler Fig: wrap an old system with the new system gradually. Parallel Run: run both and compare. Feature Toggle: feature flags. Data Decomposition: Performance: joins? Integrity: cascading? Transactions: distributed transactions, sagas? Reporting database for external reading. Communication styles TODO\n","permalink":"https://xiang.es/posts/microservices/","summary":"\u003cp\u003eSome notes about microservices\u003c/p\u003e","title":"üìù Microservices notes"},{"content":"Some notes about DDD\nReferences Awesome Domain-Driven Design Cosmic Python Domain-Driven Design Implementing Domain-Driven Design Domain Use @dataclass(frozen=True) for value objects For entities (objects with long lived identity, aka Reference Objects) use a normal class and implement __eq__ and __hash__ Don\u0026rsquo;t use FooBuilder, BarManager classes, just functions Repository Use Protocol instead of abc. Leave .commit() as a responsibility for the caller. For simple cases this abstraction is unnecessary, you can just stick with ORMs. Create an in-memory FakeRepository for testing. Info\nSome people consider \u0026ldquo;monkeypatching\u0026rdquo; a code smell and prefer using Fakes.\nService Pass the repository as a parameter to service-layer functions and use primitives instead of Domain objects. Leave endpoints as a thin wrapper for parsing and returning HTTP responses, but you can combine controller/views if it is just a web app. Write tests for the service layer. Unit of Work Use context manager and initialize the repository on __enter__. Explicit commit is recommended for easier state flushing. Add uow to the service layer. Aggregates and Consistency Boundaries An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes.\nConfigure version counters for Optimistic Concurrency Control. Retry on conflict. The only repository that should be used is the one for the aggregate. Part 1: https://github.com/cosmicpython/code/tree/chapter_07_aggregate\nEvents and Message Bus To avoid violating the single responsibility principle, use events instead of commands. A message bus is a dict that maps event types to a list of handlers. Rethink API calls as capturing events. Services will have only 2 params: the event and the uow. Commands If at first you don‚Äôt succeed, retry the operation with an exponentially increasing back-off period.\nCommands are usually imperative verbs and expect a response. Events are usually past-tense verbs and broadcasted. Event-Driven Architecture Use an external message broker (redis, kafka, rabbitmq). Two services should accept eventual consistency between them. Avoid the Distributed Big Ball of Mud, think in terms of verbs / business processes with asynchronous communication. https://martinfowler.com/articles/201701-event-driven.html\nCommand-Query Responsibility Separation (CQRS) Create thin views for our data: via raw SQL?? (repository are clunky and ORMs slow). Dependency Injection (DI) Dependency Injection vs Monkeypatching. Part 2: https://github.com/cosmicpython/code\n","permalink":"https://xiang.es/posts/ddd/","summary":"\u003cp\u003eSome notes about DDD\u003c/p\u003e","title":"üìù Domain Driven Design notes"},{"content":"Some notes about design patterns\nBehavioral Strategy Pattern Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\nHAS-A can be better than IS-A Duck - flyBehavior # classes or functions - quackBehavior # classes or functions - swim() - display() - performFly() - performQuack() Observer Pattern Maintains a list of dependents and notifies them of any state changes.\n# define a generic observer type class Observer(Protocol): def update(self, subject: Subject) -\u0026gt; None: ... class Subject: def __init__(self) -\u0026gt; None: self._observers: list[Observer] = [] def attach(self, observer: Observer) -\u0026gt; None: if observer not in self._observers: self._observers.append(observer) def detach(self, observer: Observer) -\u0026gt; None: with suppress(ValueError): self._observers.remove(observer) def notify(self, modifier: Observer | None = None) -\u0026gt; None: for observer in self._observers: if modifier != observer: observer.update(self) Command Pattern Command pattern decouples the object invoking a job from the one who knows how to do it. As mentioned in the GoF book, a good example is in menu items. You have a menu that has lots of items. Each item is responsible for doing a special thing and you want your menu item just call the execute method when it is pressed. To achieve this you implement a command object with the execute method for each menu item and pass to it.\nclass HideFileCommand: def __init__(self) -\u0026gt; None: self._hidden_files: List[str] = [] def execute(self, filename: str) -\u0026gt; None: self._hidden_files.append(filename) def undo(self) -\u0026gt; None: filename = self._hidden_files.pop() class DeleteFileCommand: def __init__(self) -\u0026gt; None: self._deleted_files: List[str] = [] def execute(self, filename: str) -\u0026gt; None: self._deleted_files.append(filename) def undo(self) -\u0026gt; None: filename = self._deleted_files.pop() class MenuItem: def __init__(self, command: Union[HideFileCommand, DeleteFileCommand]) -\u0026gt; None: self._command = command def on_do_press(self, filename: str) -\u0026gt; None: self._command.execute(filename) def on_undo_press(self) -\u0026gt; None: self._command.undo() item1 = MenuItem(DeleteFileCommand()) item2 = MenuItem(HideFileCommand()) test_file_name = \u0026#39;test-file\u0026#39; item1.on_do_press(test_file_name) item1.on_undo_press() item2.on_do_press(test_file_name) item2.on_undo_press() Template Method Pattern Defines the skeleton of a base algorithm, deferring definition of exact steps to subclasses.\ndef template_function(getter, converter=False, to_save=False) -\u0026gt; None: data = getter() print(f\u0026#34;Got `{data}`\u0026#34;) if len(data) \u0026lt;= 3 and converter: data = converter(data) else: print(\u0026#34;Skip conversion\u0026#34;) if to_save: saver() print(f\u0026#34;`{data}` was processed\u0026#34;) Iterator Pattern Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.\ndef count_to(count: int): \u0026#34;\u0026#34;\u0026#34;Counts by word numbers, up to a maximum of five\u0026#34;\u0026#34;\u0026#34; numbers = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34;] yield from numbers[:count] # Test the generator def count_to_five() -\u0026gt; None: return count_to(5) State Pattern Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nclass State: \u0026#34;\u0026#34;\u0026#34;Base state. This is to share functionality\u0026#34;\u0026#34;\u0026#34; def scan(self) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Scan the dial to the next station\u0026#34;\u0026#34;\u0026#34; self.pos += 1 if self.pos == len(self.stations): self.pos = 0 print(f\u0026#34;Scanning... Station is {self.stations[self.pos]} {self.name}\u0026#34;) class AmState(State): def __init__(self, radio: Radio) -\u0026gt; None: self.radio = radio self.stations = [\u0026#34;1250\u0026#34;, \u0026#34;1380\u0026#34;, \u0026#34;1510\u0026#34;] self.pos = 0 self.name = \u0026#34;AM\u0026#34; def toggle_amfm(self) -\u0026gt; None: print(\u0026#34;Switching to FM\u0026#34;) self.radio.state = self.radio.fmstate class FmState(State): def __init__(self, radio: Radio) -\u0026gt; None: self.radio = radio self.stations = [\u0026#34;81.3\u0026#34;, \u0026#34;89.1\u0026#34;, \u0026#34;103.9\u0026#34;] self.pos = 0 self.name = \u0026#34;FM\u0026#34; def toggle_amfm(self) -\u0026gt; None: print(\u0026#34;Switching to AM\u0026#34;) self.radio.state = self.radio.amstate class Radio: \u0026#34;\u0026#34;\u0026#34;A radio. It has a scan button, and an AM/FM toggle switch.\u0026#34;\u0026#34;\u0026#34; def __init__(self) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;We have an AM state and an FM state\u0026#34;\u0026#34;\u0026#34; self.amstate = AmState(self) self.fmstate = FmState(self) self.state = self.amstate def toggle_amfm(self) -\u0026gt; None: self.state.toggle_amfm() def scan(self) -\u0026gt; None: self.state.scan() Chain of Responsibility Pattern The Chain of responsibility is an object oriented version of the if ... elif ... elif ... else ... idiom, with the benefit that the condition‚Äìaction blocks can be dynamically rearranged and reconfigured at runtime.\nMediator Pattern Objects in a system communicate through a Mediator instead of directly with each other. This reduces the dependencies between communicating objects, thereby reducing coupling.\nMemento Pattern Provides the ability to restore an object to its previous state.\nVisitor Pattern Separates an algorithm from an object structure on which it operates.\nStructural Decorator Pattern The Decorator pattern is used to dynamically add a new feature to an object without changing its implementation. It differs from inheritance because the new feature is added only to that particular object, not to the entire subclass.\nClasses should be open for extension, but closed for modification. class TextTag: def __init__(self, text: str) -\u0026gt; None: self._text = text def render(self) -\u0026gt; str: return self._text class BoldWrapper(TextTag): def __init__(self, wrapped: TextTag) -\u0026gt; None: self._wrapped = wrapped def render(self) -\u0026gt; str: return f\u0026#34;\u0026lt;b\u0026gt;{self._wrapped.render()}\u0026lt;/b\u0026gt;\u0026#34; class ItalicWrapper(TextTag): def __init__(self, wrapped: TextTag) -\u0026gt; None: self._wrapped = wrapped def render(self) -\u0026gt; str: return f\u0026#34;\u0026lt;i\u0026gt;{self._wrapped.render()}\u0026lt;/i\u0026gt;\u0026#34; Adapter Pattern The Adapter pattern provides a different interface for a class. We can think about it as a cable adapter that allows you to charge a phone somewhere that has outlets in a different shape. Following this idea, the Adapter pattern is useful to integrate classes that couldn\u0026rsquo;t be integrated due to their incompatible interfaces.\nclass Adapter: \u0026#34;\u0026#34;\u0026#34;Adapts an object by replacing methods. Usage ------ dog = Dog() dog = Adapter(dog, make_noise=dog.bark) \u0026#34;\u0026#34;\u0026#34; def __init__(self, obj: T, **adapted_methods: Callable): \u0026#34;\u0026#34;\u0026#34;We set the adapted methods in the object\u0026#39;s dict.\u0026#34;\u0026#34;\u0026#34; self.obj = obj self.__dict__.update(adapted_methods) def __getattr__(self, attr): \u0026#34;\u0026#34;\u0026#34;All non-adapted calls are passed to the object.\u0026#34;\u0026#34;\u0026#34; return getattr(self.obj, attr) def original_dict(self): \u0026#34;\u0026#34;\u0026#34;Print original object dict.\u0026#34;\u0026#34;\u0026#34; return self.obj.__dict__ Facade Pattern The Facade pattern is a way to provide a simpler unified interface to a more complex system. It provides an easier way to access functions of the underlying system by providing a single entry point.\nclass ComputerFacade: def __init__(self): self.cpu = CPU() self.memory = Memory() self.ssd = SolidStateDrive() def start(self): self.cpu.freeze() self.memory.load(\u0026#34;0x00\u0026#34;, self.ssd.read(\u0026#34;100\u0026#34;, \u0026#34;1024\u0026#34;)) self.cpu.jump(\u0026#34;0x00\u0026#34;) self.cpu.execute() Composite Pattern The composite pattern describes a group of objects that is treated the same way as a single instance of the same type of object. The intent of a composite is to \u0026ldquo;compose\u0026rdquo; objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.\nclass Graphic(ABC): @abstractmethod def render(self) -\u0026gt; None: raise NotImplementedError(\u0026#34;You should implement this!\u0026#34;) class CompositeGraphic(Graphic): def __init__(self) -\u0026gt; None: self.graphics: List[Graphic] = [] def render(self) -\u0026gt; None: for graphic in self.graphics: graphic.render() def add(self, graphic: Graphic) -\u0026gt; None: self.graphics.append(graphic) def remove(self, graphic: Graphic) -\u0026gt; None: self.graphics.remove(graphic) class Ellipse(Graphic): def __init__(self, name: str) -\u0026gt; None: self.name = name def render(self) -\u0026gt; None: print(f\u0026#34;Ellipse: {self.name}\u0026#34;) ellipse1 = Ellipse(\u0026#34;1\u0026#34;) ellipse2 = Ellipse(\u0026#34;2\u0026#34;) graphic1 = CompositeGraphic() graphic2 = CompositeGraphic() graphic1.add(ellipse1) graphic1.add(ellipse2) # Here graphic = CompositeGraphic() graphic.add(graphic1) graphic.add(graphic2) graphic.render() Proxy Pattern Proxy is used in places where you want to add functionality to a class without changing its interface. The main class is called Real Subject. A client should use the proxy or the real subject without any code change, so both must have the same interface. Logging and controlling access to the real subject are some of the proxy pattern usages.\nclass Subject: \u0026#34;\u0026#34;\u0026#34; As mentioned in the document, interfaces of both RealSubject and Proxy should be the same, because the client should be able to use RealSubject or Proxy with no code change. Not all times this interface is necessary. The point is the client should be able to use RealSubject or Proxy interchangeably with no change in code. \u0026#34;\u0026#34;\u0026#34; def do_the_job(self, user: str) -\u0026gt; None: raise NotImplementedError() class RealSubject(Subject): \u0026#34;\u0026#34;\u0026#34; This is the main job doer. External services like payment gateways can be a good example. \u0026#34;\u0026#34;\u0026#34; def do_the_job(self, user: str) -\u0026gt; None: print(f\u0026#34;I am doing the job for {user}\u0026#34;) class Proxy(Subject): def __init__(self) -\u0026gt; None: self._real_subject = RealSubject() def do_the_job(self, user: str) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; logging and controlling access are some examples of proxy usages. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;[log] Doing the job for {user} is requested.\u0026#34;) if user == \u0026#34;admin\u0026#34;: self._real_subject.do_the_job(user) else: print(\u0026#34;[log] I can do the job just for `admins`.\u0026#34;) Model-View-Controller Pattern Separates data in GUIs from the ways it is presented, and accepted.\nBridge Pattern Decouples an abstraction from its implementation.\nFlyweight Pattern This pattern aims to minimise the number of objects that are needed by a program at run-time. A Flyweight is an object shared by multiple contexts, and is indistinguishable from an object that is not shared.\nCreational Factory Pattern A Factory is an object for creating other objects.\nDepend upon abstractions. Do not depend upon concrete classes. class GreekLocalizer: def __init__(self) -\u0026gt; None: self.translations = {\u0026#34;dog\u0026#34;: \u0026#34;œÉŒ∫œçŒªŒøœÇ\u0026#34;, \u0026#34;cat\u0026#34;: \u0026#34;Œ≥Œ¨œÑŒ±\u0026#34;} def localize(self, msg: str) -\u0026gt; str: return self.translations.get(msg, msg) class EnglishLocalizer: def localize(self, msg: str) -\u0026gt; str: return msg def get_localizer(language: str = \u0026#34;English\u0026#34;) -\u0026gt; object: localizers = { \u0026#34;English\u0026#34;: EnglishLocalizer, \u0026#34;Greek\u0026#34;: GreekLocalizer, } return localizers[language]() Abstract Factory Pattern In Java and other languages, the Abstract Factory Pattern serves to provide an interface for creating related/dependent objects without need to specify their actual class.\nclass PetShop: \u0026#34;\u0026#34;\u0026#34;A pet shop\u0026#34;\u0026#34;\u0026#34; def __init__(self, animal_factory: Type[Pet]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;pet_factory is our abstract factory. We can set it at will.\u0026#34;\u0026#34;\u0026#34; self.pet_factory = animal_factory def buy_pet(self, name: str) -\u0026gt; Pet: \u0026#34;\u0026#34;\u0026#34;Creates and shows a pet using the abstract factory\u0026#34;\u0026#34;\u0026#34; pet = self.pet_factory(name) print(f\u0026#34;Here is your lovely {pet}\u0026#34;) return pet # Create a random animal def random_animal(name: str) -\u0026gt; Pet: \u0026#34;\u0026#34;\u0026#34;Let\u0026#39;s be dynamic!\u0026#34;\u0026#34;\u0026#34; return random.choice([Dog, Cat])(name) Singleton Pattern Ensure a class only has one instance, and provide a global point of access to it.\nIn python modules are only imported once. Just declare a variable there.\nBuilder Pattern It decouples the creation of a complex object and its representation, so that the same process can be reused to build objects from the same family. This is useful when you must separate the specification of an object from its actual representation (generally for abstraction).\nPrototype Pattern This patterns aims to reduce the number of classes required by an application. Instead of relying on subclasses it creates objects by copying a prototypical instance at run-time.\n","permalink":"https://xiang.es/posts/patterns/","summary":"\u003cp\u003eSome notes about design patterns\u003c/p\u003e","title":"üìù Design Patterns notes"},{"content":"Some notes about system design\nReferences System design primer High Scalability Designing data intensive System design interview Scaling NoSQL for: low latency unstructured or non relational data only need to serialize and deserialize (json, xml, yaml, etc) store massive amount of data consistency is not a big deal, consistent scaling. Cache: read frequenly, modified infrequently implement expiration policy consistency is hard for multiple regions eviction policy: LRU, LFU, FIFO CDN: Dynamic content caching?? Cache static content near the user The origin returns TTL to describe how long to cache. Move session data out of web servers and into a cache / NoSQL. Message queue for async tasks, pub/sub. Sharding: choose a good sharding key / partition key reshard when a single shard is not enough, have exhausted shards due to uneven distribution. beware of celebrity problem, what if Justin Bieber and Lady gaga are in the same shard. joins are hard in sharded databases, try denormalizing. Back of the envelope estimation Powers of two\nPower Exact Value Approx Value Bytes --------------------------------------------------------------- 7 128 8 256 10 1024 1 thousand 1 KB 16 65,536 64 KB 20 1,048,576 1 million 1 MB 30 1,073,741,824 1 billion 1 GB 32 4,294,967,296 4 GB 40 1,099,511,627,776 1 trillion 1 TB Latency\nLatency Comparison Numbers -------------------------- L1 cache reference 0.5 ns Branch mispredict 5 ns L2 cache reference 7 ns 14x L1 cache Mutex lock/unlock 25 ns Main memory reference 100 ns 20x L2 cache, 200x L1 cache Compress 1K bytes with Zippy 10,000 ns 10 us Send 1 KB bytes over 1 Gbps network 10,000 ns 10 us Read 4 KB randomly from SSD* 150,000 ns 150 us ~1GB/sec SSD Read 1 MB sequentially from memory 250,000 ns 250 us Round trip within same datacenter 500,000 ns 500 us Read 1 MB sequentially from SSD* 1,000,000 ns 1,000 us 1 ms ~1GB/sec SSD, 4X memory HDD seek 10,000,000 ns 10,000 us 10 ms 20x datacenter roundtrip Read 1 MB sequentially from 1 Gbps 10,000,000 ns 10,000 us 10 ms 40x memory, 10X SSD Read 1 MB sequentially from HDD 30,000,000 ns 30,000 us 30 ms 120x memory, 30X SSD Send packet CA-\u0026gt;Netherlands-\u0026gt;CA 150,000,000 ns 150,000 us 150 ms Notes ----- 1 ns = 10^-9 seconds 1 us = 10^-6 seconds = 1,000 ns 1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns Availability % Downtime per day Downtime per year 99% 14.40 minutes 3.65 days 99.9% 1.44 minutes 8.77 hours 99.99% 8.64 seconds 52.60 minutes 99.999% 864.00 milliseconds 5.26 minutes 99.9999% 86.40 milliseconds 31.56 seconds The Twelve-Factor App Codebase: Use VCS (git), one codebase per app. Refactor shared code into libraries. Dependencies: Declare and isolate dependencies, vendor if necessary. Config: Use environment variables, do not group them together. Backing services: Treat them (MySQL, RabbitMQ) as attached resources via config. Build, release, run: Strict separation between these stages, releases cannot be mutated and are append-only. Processes: Processes are stateless and share-nothing. Implement sticky sessions using Memcached or Redis. Port binding: Export services via port binding. Concurrency: Scale out via the process model horizontally. Disposability: Fast startup and graceful shutdown using disposable processes. Dev/prod parity: Keep development, staging, and production as similar as possible, continuous deployment. Logs: Print unbuffered to stdout and should be captured by the executing environment. Admin processes: Run admin/management tasks as one-off processes. Scalability for Dummies Hide servers behing a load balancer. Servers does not store any user related data, store sessions in an external cache. Denormalize and use NoSQL + cache Try to retrieve data from cache and use database on miss. Cache objects (sessions, articles, activity streams, user relations) instead of queries. Async Precomputing (pre-render static html for CDN) Job queues Examples: Twitter: Primer, CodelyTV, Exponent Fanout Pastebin: Primer Dropbox: Stanford, TikTok: Exponent Instagram: Exponent Blogs Airbnb Cloudflare Discord DoorDash Dropbox Linkedin Meta Pinterest Riot Stripe Twitter Uber ","permalink":"https://xiang.es/posts/system-design/","summary":"\u003cp\u003eSome notes about system design\u003c/p\u003e","title":"üìù System Design notes"},{"content":"Overview of the CP-SAT solver from Google OR-Tools\nReferences: Laurent Perron and Fr√©d√©ric Didier, CPAIOR 2020: https://youtu.be/lmy1ddn4cyw Peter J. Stuckey, Search is Dead: https://people.eng.unimelb.edu.au/pstuckey/PPDP2013.pdf Model Building The first step is building the model using the CPModel class. This class is actually a wrapper around the cp_model protobuf.\nLet\u0026rsquo;s see an example (source):\nfrom ortools.sat.python import cp_model \u0026#34;\u0026#34;\u0026#34;Minimal CP-SAT example to showcase calling the solver.\u0026#34;\u0026#34;\u0026#34; # Creates the model. # [START model] model = cp_model.CpModel() # [END model] # Creates the variables. # [START variables] num_vals = 3 x = model.NewIntVar(0, num_vals - 1, \u0026#39;x\u0026#39;) y = model.NewIntVar(0, num_vals - 1, \u0026#39;y\u0026#39;) z = model.NewIntVar(0, num_vals - 1, \u0026#39;z\u0026#39;) # [END variables] # Creates the constraints. # [START constraints] model.Add(x != y) # [END constraints] # Creates a solver and solves the model. # [START solve] solver = cp_model.CpSolver() status = solver.Solve(model) # [END solve] if status == cp_model.FEASIBLE: print(\u0026#39;x = %i\u0026#39; % solver.Value(x)) print(\u0026#39;y = %i\u0026#39; % solver.Value(y)) print(\u0026#39;z = %i\u0026#39; % solver.Value(z)) This model creates the following proto print(str(model)):\nvariables { name: \u0026#34;x\u0026#34; domain: 0 domain: 2 } variables { name: \u0026#34;y\u0026#34; domain: 0 domain: 2 } variables { name: \u0026#34;z\u0026#34; domain: 0 domain: 2 } constraints { linear { vars: 1 vars: 0 coeffs: -1 coeffs: 1 domain: -9223372036854775808 domain: -1 domain: 1 domain: 9223372036854775807 } } Note: int64 is [-9223372036854775808, 9223372036854775807]\nPresolve Loop First stage: We will process all active constraints until a fix point is reached. During this stage:\nVariable will never be deleted, but their domain will be reduced. Constraint will never be deleted (they will be marked as empty if needed). New variables and new constraints can be added after the existing ones. Constraints are added only when needed to the mapping_problem if they are needed during the postsolve. Second stage:\nAll the variables domain will be copied to the mapping_model. Everything will be remapped so that only the variables appearing in some constraints will be kept and their index will be in [0, num_new_variables). - source Presolve: Domain reduction, constraint simplification/rewrite Constraint expansion/decomposition: Similar to Minizinc -\u0026gt; Flatzinc (element constraint, table, automaton, inverse, product, modulo, reservoir) Detect variable equivalence and affine relations. Substitute by canonical representation. Probing: Fix variables and see what is propagated. This produces 2 new models, the inner model that will be solved and a channeling model used to populate the solution of the initial model. - source\nSolver The CP-SAT solver uses a lazy clause generation solver on top of an SAT solver. The best description is a presentation from Peter Stuckey called Search is Dead - Laurent Perron\nIn Lazy clause generation (LCG), integer variables are encoded as booleans, ortools creates 2 booleans for each variable and value:\nvar == value var \u0026lt;= value Note: var \u0026gt;= value (represented as ![x \u0026lt;= value-1])\n(var == value) \u0026lt;=\u0026gt; (var \u0026gt;= value) and (var \u0026lt;= value) (var \u0026lt;= value) =\u0026gt; (var \u0026lt;= value+1) Propagation is clause generation:\ne.g. [x \u0026lt;= 2] and x \u0026gt;= y means that [y \u0026lt;= 2] clause [x \u0026lt;= 2] =\u0026gt; [y \u0026lt;= 2] Linear relaxation TODO\nDefault search (single thread) VSIDS on the Boolean problem, when it reaches a fixed point, it asks the heuristic to select an integer variable, a value and a braching direction.\nMultithreading The solver uses the first X threads to generic methods, and use all the remaining ones on LNS (Large Neighborhood Search). -Laurent Perron\n","permalink":"https://xiang.es/posts/explaining-cp-sat/","summary":"\u003cp\u003eOverview of the CP-SAT solver from Google OR-Tools\u003c/p\u003e","title":"üéì How the CP-SAT solver works"},{"content":"How I set up this website using GitHub Pages, namecheap and Cloudflare\nInfo\nI have migrated my website to Hugo PaperMod.\nRead the Papermod Guide and how to host on Github for more info.\nGitHub Pages GitHub Pages is a free and easy way to host a static website. It also works with jekyll, making creating a personal blog very easy.\nSelecting a theme There are a lot of different themes that you can choose from on GitHub.\nIn my case I pretty much chose the first one: Minimal Mistakes and used the starter from its guide.\nAfter setting stradivari96.github.io as the repository name and enabling github pages in the settings, the website was up and running.\nCustom Domain I wanted to use a custom domain name for my site, so I went to namecheap and purchased xiang.dev given that Google released this domain quite recently.\nI used Cloudflare to handle the redirect and SSL certificates for the site, it is completely free and quite easy to use.\nThis guide by Bart de Goede is quite detailed and explains this step quite well.\nYou may also need to set up A records on Cloudflare pointing to the IPs owned by GitHub.\nNote: Don\u0026rsquo;t forget to also change the nameservers of your domain to the ones provided by cloudflare.\n","permalink":"https://xiang.es/posts/website-setup/","summary":"\u003cp\u003eHow I set up this website using GitHub Pages, namecheap and Cloudflare\u003c/p\u003e","title":"üîß Website Setup"},{"content":"Software engineer at Paradigma Digital.\nAvid gamer, reader and weeb.\nLanguages: üá™üá∏, üá®üá≥, üá¨üáß and learning üáØüáµ\nExperience Date Position Company 09/2021 - Present Software Engineer 04/2021 - 09/2021 Software Engineer 09/2018 - 01/2021 Full Stack Engineer 09/2017 - 12/2017 Web Development Intern Education Title Organization Master in Computer Science (In Progress) Degree in Mathematics and Computer Science Other Fandom Wiki admin: Hollow Knight (ES) Blasphemous (ES) Contributor: Google OR-Tools: Open Source Peer Bonus winner ","permalink":"https://xiang.es/about/","summary":"Software engineer at Paradigma Digital.\nAvid gamer, reader and weeb.\nLanguages: üá™üá∏, üá®üá≥, üá¨üáß and learning üáØüáµ\nExperience Date Position Company 09/2021 - Present Software Engineer 04/2021 - 09/2021 Software Engineer 09/2018 - 01/2021 Full Stack Engineer 09/2017 - 12/2017 Web Development Intern Education Title Organization Master in Computer Science (In Progress) Degree in Mathematics and Computer Science Other Fandom Wiki admin: Hollow Knight (ES) Blasphemous (ES) Contributor: Google OR-Tools: Open Source Peer Bonus winner ","title":"About me"},{"content":"Here are some of my personal projects.\nGithub Google OR-Tools contibutions: Some contributions to the Google OR-Tools project. Awesome OR: A curated list of awesome Operations Research resources. Python Web Frameworks stars Hollow Knight Hollow Knight Wikia Loved that game and decided to translate the english wikia into spanish. Hollow Knight Translator Tool to search of in-game translations.\nFinal Degree Project (University) Generating quality 2D polygon meshes using Restricted Delaunay Triangulations.\nOther Acknowledged: Towards Explainability of On-board Satellite Scheduling for End User Interactions ","permalink":"https://xiang.es/projects/","summary":"Here are some of my personal projects.\nGithub Google OR-Tools contibutions: Some contributions to the Google OR-Tools project. Awesome OR: A curated list of awesome Operations Research resources. Python Web Frameworks stars Hollow Knight Hollow Knight Wikia Loved that game and decided to translate the english wikia into spanish. Hollow Knight Translator Tool to search of in-game translations.\nFinal Degree Project (University) Generating quality 2D polygon meshes using Restricted Delaunay Triangulations.","title":"Projects"}]